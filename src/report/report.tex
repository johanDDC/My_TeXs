% Это основная команда, с которой начинается любой \LaTeX-файл. Она отвечает за тип документа, с которым связаны основные правил оформления текста.
\documentclass[12pt]{article}

% Здесь идет преамбула документа, тут пишутся команды, которые настраивают LaTeX окружение, подключаете внешние пакеты, определяете свои команды и окружения. В данном случае я это делаю в отдельных файлах, а тут подключаю эти файлы.

% Здесь я подключаю разные стилевые пакеты. Например возможности набирать особые символы или возможность компилировать русский текст. Подробное описание внутри.
\usepackage{packages}

% Здесь я определяю разные окружения, например, теоремы, определения, замечания и так далее. У этих окружений разные стили оформления, кроме того, эти окружения могут быть нумерованными или нет. Все подробно объяснено внутри.
\usepackage{environments}

% Здесь я определяю разные команды, которых нет в LaTeX, но мне нужны, например, команда \tr для обозначения следа матрицы. Или я переопределяю LaTeX команды, которые работают не так, как мне хотелось бы. Типичный пример мнимая и вещественная часть комплексного числа \Im, \Re. В оригинале они выглядят не так, как мы привыкли. Кроме того, \Im еще используется и для обозначения образа линейного отображения. Подробнее описано внутри.
\usepackage{commands}

% Пакет для титульника исследовательского проекта
\usepackage{titlepage}
\bibliographystyle{plain}

% Здесь задаем параметры титульной страницы
\setTitle{Web-приложение для построения отчётов.}
\setGroup{195}
%сюда можно воткнуть картинку подписи
\setStudentSgn{
    \includegraphics[scale=0.1]{./sign.pdf}
}
\setStudent{И.Д. Пешехонов}
\setStudentDate{29.05.2021}
\setAdvisor{Пешехонов Дмитрий Вячеславович}
\setAdvisorTitle{Software developer}
\setAdvisorAffiliation{ООО ALM Works}
\setAdvisorDate{29.05.2021}
\setGrade{7}
%сюда можно воткнуть картинку подписи
\setAdvisorSgn{
    \includegraphics[scale=0.35]{./dad_sign.png}
}
\setYear{2021}

\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
    backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
    basicstyle=\footnotesize,        % the size of the fonts that are used for the code
    breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
    breaklines=true,                 % sets automatic line breaking
    captionpos=b,                    % sets the caption-position to bottom
    commentstyle=\color{mygreen},    % comment style
    deletekeywords={...},            % if you want to delete keywords from the given language
    escapeinside={(*@}{@*)},          % if you want to add LaTeX within your code
    extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
    keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
    keywordstyle=\color{blue},       % keyword style
    language=Java,                 % the language of the code
    morekeywords={*, string, Map, type, number, function},            % if you want to add more keywords to the set
    rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
    showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
    showstringspaces=false,          % underline spaces within strings only
    showtabs=false,                  % show tabs within strings adding particular underscores
    stringstyle=\color{mymauve},     % string literal style
    tabsize=4,                       % sets default tabsize to 2 spaces
    title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


% С этого момента начинается текст документа
\begin{document}

% Эта команда создает титульную страницу
    \makeTitlePage

% Здесь будет автоматически генерироваться содержание документа
    \tableofcontents
    \newpage

% Данное окружение оформляет аннотацию: краткое описание текста выделенным абзацем после заголовка
%    \begin{abstract}
%        Текст аннотации. Здесь кратко в два-три предложения описываем, что происходит в работе.
%    \end{abstract}


    \section{Основные термины и определения}
    \defin{API (прикладной интерфейс программы)} --- набор инструкций, процедур или констант,
    с помощью которых одна программа взаимодействует с другой. API определяет интерфейс взаимодействия с программой,
    позволяя абстрагироваться от её непосредственной имплементации\cite{API};

    \defin{REST} --– вид архитектуры взаимодействия компонентов распределённого приложения в сети.
    Представляет собой набор ограничений и программных решений, учитываемых при проектировании распределённой системы\cite{RestApiTutorial};

    \defin{База данных (БД)} --– организованная в соответствии с определёнными правилами и поддерживаемая в памяти компьютера
    совокупность данных, характеризующая актуальное состояние некоторой предметной области и используемая для
    удовлетворения информационных потребностей пользователей\cite{BD_enc};

    \defin{Реляционная база данных} --- БД, основанная на реляционной модели данных, т.е. модели данных, построенной на базе реляционной алгебры, и
    интерпретирующей множество данных в базе как набор отношений.

    \defin{MongoDB} --- документоориентированная система управления базами данных, не требующая описания схемы таблиц.
    Использует JSON-подобные документы и схему базы данных\cite{MDBIntro}.

    \defin{Mongo document} --- аналог записи в реляционных базах данных. В отличие от записей документы могут хранить информацию со сложной структурой.
    Документ можно представить как хранилище ключей и значений. Ключ представляет строковую метку, с которой ассоциировано определенные данные\cite{MDBIntro}.

    \defin{Mongo collection} --- аналог таблицы в реляционных базах данных. В отличие от таблиц могут хранить занородные объект с различной структурой
    и набором свойств\cite{MDBIntro}.

    \defin{Схема (коллекции) базы данных} --- объекты, содержащий информацию о полях в определённой коллекции базы данных на основе MongoDB, и о типах
    этих полей. Слово ``коллекция'' будет далее часто опускаться.

    \defin{Отчёт} --- Информация, представимая в виде Java-Script-объекта, которая не обязана
    непосредственно присутствовать в базе, но может быть получена из имеющихся в базе
    данных для решения текущей задачи.

    \defin{Server-side компоненты} -- код на языке программирования Java, подставляющий собой объекты, удовлетворяющие спецификации
    JAX RS. Server-size компоненты не должны иметь никаких локальных зависимостей, что позволяет безболезненно встраивать из
    в любой сервер;

    \defin{Maven} --- фреймворк для автоматизации сборки и поддержки Java-приложения\cite{maven};
    \newpage


    \section{Введение}
    В коммерческих компаниях нередко возникает необходимость оценить результат своей деятельности за некоторый промежуток
    времени. Стадии оценки деятельности предшествует стадия составления отчёта --- документа, который резюмирует деятельность
    организации в некоторой сфере её интересов. Подавляющее большинство организаций сейчас хранят результаты своей работы
    в базах данных, и при составлении отчёта бывает полезно и наглядно использовать хранящиеся данные. На самом деле,
    оценка деятельности организации --- не единственный случай, когда необходимо составить отчёт, в некоторых
    организациях отчёты необходимо составлять каждую неделю. Как правило, необходимость стоить отчёты возникает у не технических специалистов:
    как правило это менеджеры, маркетологи, секретари и т.д. Проблема здесь заключается в том, что чтобы составить отчёт, нужно иметь доступ к данным
    в базе. Есть два распостраненных способа решить эту проблему:
    \begin{enumerate}
        \item Вирту альные инструменты построения запросов к БД (конструктору запросов и т.д);
        \item Использование языка запросов БД (например SQL для реляционных баз);
    \end{enumerate}
    Первый способ зависит от конкретного инструмента, а потому потенциально имеет функциональные ограничения. Второй же способ требует хорошего
    знания языка (как правило, декларативного, что в разы усложняет процесс отладки), и не предназначен для не специалистов.

    Одной из организаций, в которых востребовано построенние отчётов с использованием данных из базы является коммерческая IT-компания OOO ALM Works.
    Организация хочет разработать приложение со следующей идеей:\\
    Построение запросов к БД будет осуществляться посредством кода на императивном языке программирования, написанного в специальном редакторе,
    обеспечивающем удобное программирование. Под удобным программированием подразумевается автодополнение кода при написании запроса. Редактор должен
    подсказывать, как составить тот или иной запрос во всех аспектах, чтобы даже человек, далёкий от программирования, мог немного изменить уже написанный
    код, воспользовавшись подсказками редактора, и получить новый отчёт.

    В необходимости решить описанную проблему составления отчётов не специалистами и заключается \textbf{актуальность моего проекта}.

    В начале года у организации не было чёткой уверенности, что такое приложение можно сделать за разумное время. До конца не были сформулированы
    требования к функционалу и к используемым программным средствам. Основной целью моего проекта является разработка концепта такого приложения и
    тестирование на нём различных подходов к автоматической генерации отчётов и методов реализации проекта подобного рода.
    Созданный концепт предполагается в дальнейшем использовать для реализации фактического приложения. Все задачи и требования к проекту будут так же
    предъявляться и к фактическому приложению.

    \subsection{Цель проекта}
    Создать концепт web-приложения для построения отчетов со сложной логикой с помощью языков программирования JavaScript/TypeScript.

    \subsection{Задачи проекта}
    \begin{enumerate}
        \item Создать web-приложение поддерживающее редактирования, исполнение и отладку введенного пользователем кода на JavaScript и TypeScript;
        \item Показывать результат исполнения кода в виде таблицы с возможностью экспорта в .csv файл;
        \item Разработать и реализовать API для генераторов отчетов. API должен предоставлять возможность отправлять на
        сервер запросы к базе в формате MongoDB, передавать в код результат исполнения запроса и принимать отчет (результат работы кода);
        \item Создать Server-side компоненты: поиск в базе данных MongoDB; передача web приложению схемы базы данных;
    \end{enumerate}

    Результатом проекта является рабочий концепт приложения с поставленными задачами, который будет далее использоваться при
    реализации реального приложения.
    \newpage


    \section{Обзор аналогов и альтернатив}

    \subsection{Альтернатива: редактор}
    В проекте предполагается использовать WEB-редактор кода, при этом уточняется, что этот редактор должен поставляться библиотекой
    и являться модулем npm (пакетный менеджер, входящий в состав Node.js). Всего есть три наиболее популярные и большие библиотеки,
    поставляющие WEB-редакторы кода для браузера:
    Ace, CodeMirror и MonacoEditor. Каждый из этих редакторов является довольно мощным инструментом и используется в каком-то большом
    проекте: так например редактор CodeMirror используется в панели разработчика в браузерах Chrome и Firefox; Ace используется в
    Codecademy и MODX, а MonacoEditor можно встретить почти везде: IDE Gitlab, Code Sandbox, оффициальный сайт Typescript, Google
    Collab и много где ещё. В проекте было решено использовать Monaco Editor по следующим причинам:
    \begin{enumerate}
        \item Наиболее развит самый важный для проекта инструмент: IntelliSense — подсказки и автодополнение кода, причём в отличие
        от CodeMirror инструмент поставляется из коробки, а не добавляется посредством аддонов;
        \item Написан на TypeScript. Проект предполагается реализовывать на TypeScript, поэтому его поддержка была важна. В редакторе
        Ace так же есть поддержка TS, но сам он был написан на Javascript, для CodeMirror определены только типы;
        \item Удобная автоматически сгенерированная документация;
        \item Наиболее красивый UI среди конкурентов;
        \item Тот факт, что в приложениях Monaco Editor встречается гораздо чаще, чем CodeMirror или Ace;
    \end{enumerate}

    Во всех библиотеках примерно одинаковый базовый функционал: автоформатирование кода, сворачивание строк, cut/copy/paste, горячие клавиши,
    возможность добавления новых синтаксисов для подсветки и тем.

    \subsection{Альтернатива: IDE}
    Основной альтернативой проекта можно считать обычную программную среду разработки.
    Среда разработки (или IDE) --- это мощный инструмент промышленного программирования, который предоставляет весь необходимый функционал
    для комфортного решения промышленных бизнес-задач. В частности, редакторы наиболее крупных и известных сред разработки часто предоставляют
    весь необходимый функционал для составления отчётов.

    Однако можно выделить два основных недостатка сред разработки перед данным проектом. Оба недостатка следуют из целевой аудитории потенциальных
    пользователей программного продукта: это люди, которым требуется просто составить отчёт, люди, которые в большинстве своём программистами не
    являются. На данный момент в ALM Works нет необходимости составлять отчёты чаще, чем раз в неделю, как нет и предпосылок к тому, что такая
    необходимость может появиться в будущем. Исходя из написанного формулируем недостатки IDE:
    \begin{enumerate}
        \item Высокий порог вхождения. Среда разработки это великое множество инструментов, объединённых в одной программе. Из всех стандартных
        инструментов, которые предоставляют наиболее известные среды разработки для составления отчётов требуется очень небольшое подмножество.
        Кроме того потенциальные пользователи не являются по своей специальности программистами, и заставлять их учиться использовать среду
        разработки для составления отчётов раз в неделю попросту неэффективно и ненужно.
        \item Использовать среду разработки для решения задачи составления отчётов не выгодно экономически. IDE часто предоставляют бесплатно базовый
        набор инструментов для личного пользования. Зачастую это просто редактор, автоматической подсветкой синтаксиса, автодополнением, подсветкой ошибок
        и дебаггером (такой набор инструментов является наименьшим по включению среди инструментариев всех IDE). Под ''личным пользованием`` подразумевается
        любое некоммерческое использование. И хотя описанный набор инструментов вполне удовлетворяет множество функциональных требований проекта, всё равно
        остаются требования, которые требуют менее тривиальных инструментов (пример: возможность видеть составленный отчёт в виде таблицы). Кроме того,
        когда мы говорим о коммерческой компании, не может быть и речи ни о каком личном пользовании. Зачастую для коммерческого использования требуется купить
        у компании-разработчика IDE коммерческую лицензию, которая как снимет ограничение на ''личное пользование``, так и предоставит дополнительный набор
        инструментов. Понятно, что покупать коммерческую лицензию среды разработки для составления отчётов раз в неделю как минимум не рентабельно.
    \end{enumerate}

    \subsection{Альтернатива: SQL}
    Альтернативным подходом к проекту так же является следующий: имея базу данных на основе SQL можно было бы просто написать запрос к базе
    на языке SQL, который бы отработал на сервере, и результатом такого запроса был бы готовый отчёт, который не нужно дополнительно
    обрабатывать, и который можно сразу представить в табличном виде (следует из специфики SQL). Среди преимуществ SQL-подхода так же то,
    что отчёт будет целиком составлен на сервере, а с сервера вернётся только полезная часть, в то время как при составлении отчётов с
    помощью разрабатываемого приложения нужно будет хранить все данные, необходимые для промежуточных вычислений. В итоговом отчёте
    может быть пара строк, но чтобы их составить может потребоваться просмотреть всю базу, соответственно, можно считать, что
    объём данных, хранимый на стороне клиента прямо пропорционален размеру базы, что, очевидно, недостаток нашего приложения.

    Перечислим теперь недостатки SQL-подхода:
    \begin{itemize}
        \item Основной недостаток состоит в том, что сложный SQL-запрос выглядит сложно. В SQL нет никаких средств факторизации кода, таких
        как функции, из-за чего сложный запрос невозможно разобрать на отдельные простые части. Так как предполагается, что приложение будет
        использоваться для построения сложных отчётов людьми, которые не очень связаны с программированием, то такая сложность SQL
        определённо является недостатком;
        \item Следующий недостаток SQL-подхода заключается в отсутсвии дебаггеров из-за самой специфики SQL. Если запрос работает не так,
        как ожидается, его нельзя исполнить пошагово и понять таким образом, что и в какой момент пошло не так. Вместо этого придётся копировать
        часть кода, проверять, работает ли правильно она (для этого, вероятно, придётся придумывать тесты), и после исправления нужно не забыть
        внести изменения в основной запрос;
        \item Третья проблема SQL-подхода состоит в безопасности. Эта проблема менее значима, чем остальные, так как её можно устранить выставлением
        прав, однако она существует, особенно в условиях того, что пользователи сервиса не являются высококвалифицированными программистами.
        Под проблемой безопасности понимается то, что в условиях, когда не выставленны соответствующие права, следующий корректный
        SQL-запрос повлечёт за собой удаление таблицы из базы данных: SELECT DROP Table;
    \end{itemize}

    Каждый из этих недостатков не относится к данному проекту: написание кода, генерирующего отчёт на JavaScript позволит не писать длинные
    сложные синтаксические конструкции, а разбивать запрос на простые отдельные части. Кроме того в проекте будет реализован механизм отладки,
    который позволит быстро понять, в чём состоит ошибка, если код работает некорректно. Проблемой однако остаётся то, что для составления
    отчёта придётся хранить все необходимые для вычислений данные в браузере, и с этим по большему счёту ничего нельзя сделать. В MongoDB
    реализован интерфейс Mongo Projection, который позволяет получить из базы только те данные, которые действительно нужны. Если реализовать
    в проекте поддержку этого интерфейса, то используя его можно снизить размер хранимых данных, просто не запрашивая из базы ненужные поля.
    \newpage


    \section{Описание функциональных и нефункциональных требований к программному проекту}

    \subsection{Описание функциональных требований}
    Компания заказчик выдвинула следующие функциональные требования к проекту:

    \subsubsection{Описание требований к составу функций}
    \begin{itemize}
        \item Наличие WEB-редактора, поддерживающего исполнение JS/TS кода, в котором определён контекст API генератора отчётов;
        \item WEB-редактор должен предоставлять удобный интерфейс для написания запросов, в частности иметь автодополнение кода для
        запрашиваемых полей и подсказывать типы запросов;
        \item Возможноть отлаживать написанный в WEB-редакторе код прямо в браузере;
        \item Наличие многоуровневого API:
        \begin{itemize}
            \item Первый уровень (низкий): связывает WEB-редактор и компонент, осуществляющий исполнение кода. Поддерживает запуск и отладку кода,
            а так же обработку ошибок;
            \item Второй уровень (высокий): поддерживает взаимодейтсвие приложения и сервера с базой данных;
        \end{itemize}
        \item Возможность отобразить отчёт в табличном виде;
        \item Возможность экспортировать отчёт в .csv файл;
%        \item Наличие Server-side компонентов: поиск в базе данных, а также передача приложению схемы базы данных;
%        \item Возможность встроить Server-side компоненты в любой другой сервер, отличный от тестового;
    \end{itemize}

    \subsubsection{Описание требований к организации входных данных}~

    \textbf{Входные данные} представляют собой программный код на языке программирования\\
    JavaScript/TypeScript, содержащий запросы
    к серверу в формате, описанном в официальной документации MongoDB \cite{QueryDoc}.
%    про протокол и Java Driver

    \textbf{Выходные данные} представляют собой отчёт, который можно отобразить в табличном виде и экспортировать в .csv файл.

    \subsubsection{Описание требований к интерфейсу приложения}~

    \textbf{Интерфейс API} должен быть представлен англоязычной документацией, содержащей описание методов и
    принимаемых параметров с примерами использования и результата работы каждого метода.

    \textbf{Интерфейс WEB-редактора} должен быть представлен текстовым полем, в котором пишется программный код на языке
    программирования JS / TS. Должна быть реализована подсветка синтаксиса, а так же автодополнение кода. Должны быть предусмотрены
    отдельные визуальные элементы, при активации которых происходит запуск кода, отображение отчёта в виде таблицы, экспорт
    отчёта в .csv файл или смена текущего диалекта JS.

    \subsubsection{Описание требований к временным характеристикам}
    Приложение должно удовлетворять всем разумным требованиям по времени, в частности, исполнение кода в редакторе не должно
    работать сильно дольше, чем происходит полный цикл отправки запроса на сервер.

    \subsubsection{Описание требований к технологиям разработки}
    Проект должен собираться с помощью Maven, допускается сборка WEB составляющей проекта в единственный JS-файл посредством webpack.
    WEB-приложение должно быть разработано на языке TypeScript c использованием фреймворка React.js, так как именно эти технологии в
    данный момент используются в ALM Works. Server-side компоненты должны быть разработаны на языке Java и удовлетворять спецификации
    JAX-RS.

    \subsection{Описание нефункциональных требований}

    \subsubsection{Описание требований к надёжности}
    Не допускается никаких сбоев в работе приложения кроме случаев, когда не работает внутренний сервер компании
    (часы обслуживания и т.д.). В этом случае допускается отказ приложения в отправке запроса на сервер.

    \subsubsection{Описание требований к условиям эксплуатации приложения, а также квалификации пользователей}
    Никаких специальных требований к условиям эксплуатации приложения не предъявляется. Все пользователи приложения являются
    сотрудниками ООО ALM Works с соответствующей квалификацией.
    \newpage


    \section{Траектория реализации проекта}

    \subsection{Начало работы. Подготовка тестового окружения}
    Для начала работы над проектом было необходимо построить трёхмодульную архитектуру:
    \begin{itemize}
        \item Первый модуль это тестовый сервер, на котором можно разместить базу данных, и все подсервисы, необходимые для комфортной
        работы с сервером;
        \item Второй модуль это сторонние server-side компоненты --- сервисы, которые занимаются не обслуживанием сервера, а
        предоставляют высокоуровневый API для запросов к базе данных;
        \item Третий модуль, это непосредственно само разрабатываемое приложение;
    \end{itemize}

    Для создания такой многомодульной структуры проекта использовались maven-модули. Структуру, зависимости и правила сборки каждого
    модуля описывает POM-файл, а так же в корне рабочей директории лежит ещё один POM-файл, в котором описаны общие для всех модулей
    зависимости, а так же то, что эти три модуля принадлежат одному проекту.

    Модуль сервера содержит простейший пример сервера на Java с использованием фреймворка Grizzly, предоставленный компанией ALM Works
    для реализации проекта. В качестве тестовой базы данных был выбран датасет продукции компании Netflix \cite{NetflixDB}. Данные
    были переведены из csv формата в формат JSON и добавлены в тестовую базу данных.

    Модуль server-side долгое время не содержал полезных компонент, вплоть до начала реализации базового Report API.

    Для проверки корректности работы тестового окружения был построен ''Hello World``-пример, задача которого была в том, что
    при загрузке web-страницы на сервер должен придти запрос, в ответ на который сервер должен был отправить текущую дату и время,
    и после получения, ответ должен быть отображён на странице.
    \begin{figure}[h]
        \center{\includegraphics{./archicture.pdf}}
        \caption{Схема модульной структуры проекта}
    \end{figure}

    Рабочий репозиторий проекта находится на Github по \href{https://github.com/johanDDC/report-builder}{ссылке}, он же драфт проекта.

    \subsection{Интеграция Monaco Editor}
    В соответствии с функциональными требованиями, реализация проекта началась с разработки web-редактора кода на языке JS/TS. Т.к. редактор
    Monaco Editor уже был выбран для проекта (смотри мотивацию выше), а так же поставляется по свободной MIT-лицензии, то было решено использовать
    использовать его в качестве редактора генератора отчётов. Monaco Editor удовлетворяет множеству требований, выдвинутых к редактору, так
    например в Monaco Editor
    \begin{itemize}
        \item Имеется автоматическая подстветка синтаксиса для установленного языка;
        \item Имеется возможность передать описания объектов, классов и методов с указанием типов аргументов и возвращаемых значений;
        \item Присутствует автодополнение кода для стандартных синтаксических конструкций языка;
        \item Присутствует автодополнение кода для переданных описаний объектов;
        \item При несовпадении типов принимаемых и переданных аргументов выделяются ошибки (для Typescript);
    \end{itemize}
    После того, как Monaco Editor был добавлен на страницу, и правильным образом сконфигурирован, стало возможно писать код на языках
    JavaScript / Typescript с подстветкой синтаксиса и подчёркиванием ошибок в простейших языковых конструкциях. Встал вопрос о том, как этот
    код запускать.

    \subsection{Учимся выполнять написанный код}
    Есть два наиболее распространённых способа скомпилировать JavaScript код, записанный в виде строки, во время исполнения программы на JavaScript:
    \begin{enumerate}
        \item Встроеная функция eval;
        \item Сконструировать новый объект типа Function, передав код в метод Function.constructor, и вызвать его.
    \end{enumerate}
    Приведём краткое описание и небольшое сравнение этих способов:

    \subsubsection{Выполнение кода с помощью eval}
    eval(str)\cite{JSeval} --- функция, входящая в стандарт JavaScript ES*\footnote{3, 5, 6, 7, 2020 и т.д.}. Принимает в качестве аргумента строковый литерал, представляющий собой
    JavaScript код и вызывает интерпретатор JS для его исполнения. eval возвращает значение выполнения переданного кода. Если код не возвращает
    ничего, то eval вернёт стандартный в таких случаях результат undefined. По умолчанию eval выполняет код в локальном контексте.
    Это значит, что eval имеет доступ ко всем объявлённым локальным переменным и функциям той области программы, из которой она вызвана.
    Более того, код, который исполняет eval, может изменить эти локальные переменные, и переопределить локальные функции, что влечёт за собой
    потенциальные проблемы в безопасности. Начиная с ES5 в JavaScript есть множество способов заставить eval выполняться в глобальм контексте,
    что лишает потенциально вредоносный код доступа к локальным переменным.

    \subsubsection{Выполнение кода с помощью Function.constructor}
    Function.constructor(param1, $\ldots$, paramN, funcBody) \cite{FuctionConstructor} --- создаёт функцию (объект типа Fucntion) c параметрами param1 ... paramN и
    телом функции funcBody. Сконстуированная функция ведёт себя как обычная функция: её можно вызвать, передав все необходимые аргументы,
    и из неё можно получить возвращаемое переданным при конструировании кодом значение, либо undefined, в случае если код не возвращает ничего.
    Сконструированная функция всегда вызывается в глобальном контексте, что позволяет избежать проблем с безопасностью.

    Для запуска полученного из редактора кода в проекте используется способ с Function.constructor по следующим причинам:
    \begin{enumerate}
        \item Так как никакой проверки корректности кода не происходит, а сам код получается из редактора, где его пишет пользователь, то
        никаких гарантий на безопасность этого кода нет и быть не может. Пользователь может поменять переменную с неправильным именем, и если
        такая переменная есть в области программы, откуда вызывается eval, то это может послужить причиной бага и привести сервис в нерабочее состояние
        до перезагрузки страницы --- совершенно недопустимая ситуация согласно нефункциональным требованиям к отказоустойчивости;
        \item При написании кода пользователь может не иметь доступа ко всему контексту программы. Пример: при написании отчёта пользователь
        имеет доступ к объекту api, который предоставляет методы query (запрос к базе данных, находящейся на сервере) и table (отображение
        отчёта в виде таблицы). Однако сам этот объект в коде пользователя отсутствует, и будет в него внедрён на этапе выполнения. На самом деле
        такой объект может даже не существовать до момента исполнения кода ввиду множества неопределённостей (неизвестно, по каким коллекциям
        пользователь будет делать запрос и т.д.), что делает невозможным создание такого объекта в глобальном контексте я последующего использования его в модифицированном eval
        \footnote{Как отмечалось выше, есть способ вызвать eval таким образом, чтобы он исполнялся в глобальном контексте. Подробнее\cite{GlobalEval}}. Конечно, можно создать объект в локальной области видимости, и вызвать там же eval,
        но в этом случае мы вынуждены полагаться на отсутсвие уезвимостей в коде пользователя, что недопустимо (см первый пункт). С другой
        стороны мы можем создать такой объект локально, и передать его функции, сгенерированной с помощью Function.constructor, которая выполниться
        в глобальном контексте, что совершенно не принципиально;
        \item Способ Function.constructor, как правило, быстрее чем eval. Это связано с тем, что eval запускает JS-интерпретатор для разбора переданного кода, в то время как Function.constructor оптимизирован многими современными JS-движками
        (как например применяемы в chrome браузере, и его производных V8).
    \end{enumerate}
    На основании всего вышеперечисленного в проекте был сделанн выбор в сторону Function.constructor.

    После реализации выполнения кода возникла следующая проблема: как правило, после получения результата запроса отчёт будет отрисовываться в
    табличном виде. Кроме того размер ответа на запрос в полевых условиях спокойно может превышать отметку в 1MB (почти 2000 записей в тестовой
    базе данных --- не очень много для отчёта). Прежде чем нарисовать таблицу, нужно разобрать ответ, представить его в виде, из которого его
    былобы проще всего отрисовывать. Если всё это делать в том же потоке, в котором работает GUI-интерфейс приложения, то это может привести
    к подвисанию графических компонент. Причём частота и продолжительность лагов будет прямо пропорциональна размеру отчёта. На этом
    основании было принято перенести исполнение исполнение написанного кода, отправление запроса и разбор ответа в отдельный поток
    с помощью интерфейса Web Workers.

    \subsection{Базовый интерфейс Report API}

    На этом этапе начальная стадия проекта была завершена: был получен редактор, поддерживающие оба требуемых языка, обладающий встроенной
    подстветкой ошибок и возможностью расширить знание о типах для автоматического дополнения кода. Код из редактора возможно запустить
    и получить результат его исполнения, причём код запускается в отдельном потоке, вследствие чего проблем визуальным потоком не возникнет
    вне зависимости от сложности запускаемого кода.
    Следующей задачей выполнения проекта стало написании базового API генератора отчётов. Требования к этому API были выдвинуты следующие:
    \begin{itemize}
        \item У пользователя в редакторе должен быть доступ к объекту api с двумя публичными методами:
        \begin{itemize}
            \item query(data : object);
            \item table(data : object);
        \end{itemize}
        \item Метод query принимает на вход объект в формате запроса к базе MongoDB, превращает его в JSON-объект и делает POST-запрос на сервер;
        \item Сервер принимает запрос и передаёт его в специальный Server-side компонент;
        \item Server-side компонент разбирает запрос и получает от базы ответ, упаковывает его в формат JSON и передаёт обратно серверу;
        \item Сервер возвращает полученный от Server-side компонента объект в качестве ответа;
        \item Метод query разбирает и возвращает результат запроса к базе данных, полученный от сервера в виде массива записей из базы данных;
        \item Метод table отрисовывает переданный ему в качестве аргумента результат запроса к базе данных в виде таблицы;
    \end{itemize}
    Пример простейшего запроса к базе MongoDB: \{\}. Такой запрос возвращает все документы из коллекции. Пример простейшего кода, который должен
    выполнять после реализации базового API: api.table(api.query(\{\})). Такой код должен получить все документы из коллекции и отобразить их
    в виде таблицы.
    В качестве тестовой базы данных был выбран датасет продукции компании Netflix. Датасет был экспортирован в формат JSON и добавлен в тестовую
    коллекцию тестовой базы данных на MongoDB.
    После изучения официальной документации MongoDB о различных типах запросов, а так же документации к Java Driver был реализован Server-side
    компонент, а затем и метод query. После того как метод query стал возвращать результат запроса к базе в виде массива, был реализован
    метод table простейшим образом: фактически реализация метода table представляла собой построчный обход двумерного массива, где первым
    измерением являются объекты-записи из базы данных, а вторым --- множество свойств каждого такого объекта. После реализации обоих методов
    query и table требования к базовому API генератора отчётов были выполнены. Позднее требования к методу table были модифицированы
    следующим образом: появился опциональный параметр columns, принимающий массив строк, в котором каждая строка является колонкой, которая
    должна быть отрисована в таблица. Каждая колонка является свойством в объекте-записи. Если такое свойство в записи отсутсвует, то
    на соответствующем месте не будет отображаться ничего. При тестировании была замечена следующая проблема: при отрисовывании
    нескольких тысяч строк таблицы основной поток довольно сильно подвисает. Чтобы исправить эту проблеу была сформулирована следующая гипотеза:
    так как таблица используется скорее для беглого просмотра с целью удостовериться в корректности результата, чем для глубоко анализа,
    можно ограничить число отрисовываемых строк. Для реализации гипотезы было добавлено специальное текстовое поле, в которое пользователь
    может ввести число строк, которое будет отображено в таблице. По умолчанию в поле выставлено значение 5. Такое уточнение позволило сильно разгрузить GUI-поток
    и избавиться от необязательных тормозов.

    \subsection{Экспорт отчёта в CSV}

    Промежуточный итог: после реализации этого этапа проекта в наличии имеется:
    \begin{itemize}
        \item Редактор кода с поддержкой обоих требуемых языков, подстветкой синтаксиса и ошибок, а так же возможность задать типы объектов из
        кастомной библиотеки;
        \item Возможность запустить код из редактора в отдельном потоке и получить результат его работы;
        \item Метод query объекта api, позволяющий сделать запрос к базе данных, находящейся на сервере. Метод поддерживает любой валидный запрос
        запрос в формате, указаном в официальной документации MongoDB Query, однако редактор кода не знает типы запросов, что не позволяет ему
        предлагать автодополнение кода;
        \item Метод table объекта api, позволяющий нарисовать таблицу, содержащую полученный ответ на запрос к базе. Есть возможность передать в метод
        список колонок, которые должны быть в таблице. В случае если список колонок не задан, колонки будут взяты из первой записи ответа;
        \item Тексовое поле, задающее ограничение на количество строк в таблице. По умолчанию поле содержит значение 5, и при измении сохраняет
        новое значение в объект localstorage, позволяющий не заставлять пользователя вводить одно и то же значение при каждой перезагрузке
        страницы;
    \end{itemize}
    На этом этапе были выполнены следующие функциональные требования (кратко):
    \begin{itemize}
        \item Наличие веб-редактора кода;
        \item Возможность исполнять код из редактора;
        \item Возможность делать запросы к базе данных MongoDB в формате MongoDB Query;
        \item Возможность видеть результат запроса в виде таблицы;
    \end{itemize}
    Следующим функциональным требованием, которое необходимо было реализовать, было требование "Наличие возможности получить результат запроса к базе
    в виде csv-файла".

    Краткое описание: CSV-формат (comma-separated values) --- текстовый формат, предназначенный для представления табличных данных. Строка
    таблицы соответствует строке текста, которая содержит одно или несколько полей, разделённых запятыми.

    В проекте допускалось использование библиотеки, которая по переданным данным построит строку в формате CSV, однако в образовательных целях было
    решено заняться имплементацией такого функционала без помощи сторонних библиотек.

    Функция, генерирующая строку в формате CSV по переданным данным была реализована следующим образом: функция принимает в качестве аргументов
    массив объектов, где каждый объект является строкой с данными, которые соответственно должны быть записаны в строки итоговой таблицы,
    а так же массив объектов, состоящих из двух свойств:
    \begin{itemize}
        \item Свойство header --- имя колонки в таблице;
        \item Свойство renderer --- функция, которая занимается отрисовкой типов данных в этой колонке;
    \end{itemize}
    Сама функция реализована в соответствие со стандартом CSV \cite{CSVStandart}, в частности предусмотрены случаи, когда поля содержат в себе
    запятые и переводы строк. После того как функция была готова и протестирована, встал вопрос о том, как скачать файл с полученным csv,
    не задействуя при этом сервер. Решение было найдено довольно простое: в тот момент, когда пользователь активирует кнопку ''скачать csv``,
    эмулируется активация ссылки, в адресе которой содержится сгенерированная csv строка. Так же в ссылке явно прописана инструкция браузеру,
    что её содержимое не нужно отрисовывать. В результате браузер, получет такую ссылку, и, не зная что ещё с ней можно сделать, предлагает
    пользователю скачать её содержимое, то есть csv-файл.

    \subsection{Построение системы типов}
    На данном этапе проекта рализованы все основные функции приложения: имеется редактор кода, возможность запускать код, видеть результат и экспортировать
    отчёт в виде таблицы. Теперь необходимо сделать имеющийся функционал удобным в использовании.

    Когда пользователь пишет код, генерирующий отчёт, он косвенно работает с базой данных. Реализованный метод api.query позволяет сделать не только самый
    примитивный запрос по типу ``принеси то, что сказали'', он так же поддерживает возможность задать промежуток значений, и получить все записи из базы,
    значение в конкретном поле которых удовлетворяет заданному промежутку. В этом плане очень показательно, что типы границ промежутка и тип поля из таблицы
    должны совпадать. В такой ситуации встаёт вопрос: как получить информацию о типах? Если пользователь перепутает тип запрашиваемого поля, то получится
    некорректный запрос, и сервер не вернёт ничего содержательного. Соответсвенно, чтобы исправить эту ситуацию, была сформулирована следующая идея:
    приложения при старте работы получает схему базы данных, после чего генерирует систему типов, которая представляет собой
    описание типов полей в запросе, и всевозможных операций с заданным полем. Когда пользователь хочет запросить то или иное поле, редактор Monaco Editor,
    которому можно передать знание о новых типах, начинает подсказывать (посредство автодополнения кода) пользователю, какой тип имеет данное поле,
    и какие операции над ним можно совершить.

    \subsubsection{Схема базы данных}

    Основным объектом, которым предстоит оперировать при реализации системы типов является схема, поэтому прежде всего стоит описать тип, соответсвующий схеме
    базы данных. В конечном итоге было выбрано следующее описание типа $Schema$, соответствующего схеме базы:
    \begin{center}
        \begin{lstlisting}
    Schema := string (*@$\vee$@*) {array: true, element: Schema} (*@$\vee$@*) Map(*@$<$@*)string, Schema(*@$>$@*) (*@$\vee$@*) string(*@$[]$@*)
        \end{lstlisting}
    \end{center}
    Это описание можно понимать следующим образом: схема --- это объектный, каждое поле которого соответствует некоторому типу.
    Приэтом этот тип может быть
    \begin{itemize}
        \item $\textcolor{blue}{\mathrm{string}}$ --- примитивным (число, строка, логическое значение);
        \item $\textcolor{blue}{\mathrm{Map}}<\textcolor{blue}{\mathrm{string}},~ \mathrm{Schema}>$ --- объектным;
        \item $\{\mathrm{array}: \textcolor{blue}{\mathrm{true}}, \mathrm{element}: \mathrm{Schema}\}$ --- массивом любого типа выше;
        \item $\textcolor{blue}{\mathrm{string}}[]$ --- enum;
    \end{itemize}
    После того, как был описан тип схемы, можно сделать саму схему тестовой базы данных для разработки системы типов (см Приложение № $2$).

%    Далее введём несколько определений:
%    \begin{definition}
%        \it{Схемой поля} $F$ назовём объект, описывающий множество подполей и их типов у
%    \end{definition}

    Далее будем рассматривать схему, как дерево (ацикличный, связный, ориентированный граф), в котором каждая вершина представляет собой название
    поля в исходной схеме, или некоторого подполя в некотором объектном типе схемы, а ребро (ориентированное) соответсвует отношению достижимости
    подполя из некоторого поля. Корнем этого дерева назовём поле DB, которое отображается в действительную схему базы данных.

    \begin{figure}[h]
        \center{\includegraphics{Tree.pdf}}
        \caption{Схема тестовой базы в виде дерева}
    \end{figure}

    Введём несколько определений для удобства:
    \begin{definition}
        \it{Уровнем схемы} назовём любое объект, содержащий значения, соответвтующие некоторому поддереву данного дерева схемы за вычетом корня.
    \end{definition}
    \begin{definition}
        \it{Первым уровнем схемы} назовём объект, соответствующий исходной схеме базы данных.
    \end{definition}
    \begin{definition}
        \it{Схемой поля} $F$ назовём объект, соответствующий поддереву с корнем в вершине, соответствующей полю $F$, находящийся на некотором уровне схемы.
    \end{definition}

    Формализуем решаемую задачу: нам предстоит сгенерировать строки, содержащие комбинации названий полей, информацию о которых мы получим из
    схемы базы данных, и приписать каждой из них тип языка TypeScript. При этом если некоторый тип является объектным, то должна быть возможность
    запросить поле с таким типом прописав все соответствующие подполя, или запросить все записи, содержащие такое поле, прописав лишь некоторые подполя.
    \begin{example}
        Рассмотрим следующую схему поля author:
        \begin{lstlisting}
    {
        "name": string,
        "surname": string,
        "birth_year": int
    }
        \end{lstlisting}
        Должна быть возможность выполнить оба следующих запроса:
        \begin{lstlisting}
    {author: {name: "Luise", surname: "Carrol", birth_year: 1832}}

    {author.name: "Luise"}
        \end{lstlisting}
    \end{example}

    \subsubsection{Операции над типами}

    Как уже упоминалось выше, при составлении запроса к MongoDB над примитивными типами можно совершать некоторое операции, как например:
    \begin{itemize}
        \item Запросить значение из базы по совпадению (по умолчанию);
        \item Запросить все значения, меньше данного;
        \item Запросить все значения, больше данного;
        \item Запросить все значения, не равные данному;
    \end{itemize}
    И другие. Все операции, существующие для одного примитивного типа, определены так же и для всех остальных примитивов, и их поведение зависит только
    от типа. Соответственно, имеет смысл описать такую структуру, которая бы принимала на вход реальный притивный тип, и отдавала все варианты операций,
    которые над ним можно совершить. Назовём такую структуру QPrimitiveType$<$T$>$, где T --- действительный примитивный тип,
    и определим её следующим образом (некоторые операции будут опущены для лучшей читаемости):
    \begin{lstlisting}
        QPrimitiveType<T> = T (*@$\vee$@*) { "$eq": T } (*@$\vee$@*) { "$gt": T } (*@$\vee$@*) { "$lt": T };
    \end{lstlisting}
    \begin{example}
        Воспользуемся схемой поля author из прошлого параграфа. Пусть Monaco Editor знает, что тип подполя name поля author имеет следующую декларацию
        в языке TypeScript:
        \begin{lstlisting}
            type name = QPrimitiveType<string>;
        \end{lstlisting}
        Тогда при вводе в редактор кода запроса поля author.name должны всплывать следующие подсказки:\\
        \begin{lstlisting}
            { "$eq": string }
            { "$gt": string }
            { "$lt": string }
        \end{lstlisting}
    \end{example}

    \subsubsection{Описание алгоритма генерации}

    Легко заметить, что если поле имеет примитивный тип, то сгенерировать соответствующий ему TypeScript-тип очень просто:
    достаточно поставить в соответствие типу MongoDB тип языка TypeScript (например типам int32, int64, float, double ставится в соответствие
    тип number), после чего, если поле имело название field, и имело примитивный тип F, то генерация TypeScript-типа, соответствующего этому
    полю имеет следующий вид:
    \begin{lstlisting}
            type field = QPrimitiveType<F>;
    \end{lstlisting}
    Не сильно сложнее сгенерировать TypeScript-тип для поля, тип которого является массивом: в этом случае если field имело тип
    $\{\mathrm{array}: \textcolor{blue}{\mathrm{true}}, \mathrm{element}: \mathrm{F}\}$, то сгенерированный тип будет иметь вид
    \begin{lstlisting}
            type field = QPrimitiveType<F(*@$[]$@*)>;
    \end{lstlisting}
    Для enum --- аналогично.\\
    Но что если поле field имело объектный тип? Тогда рассмотрим поддерево, соответствующее схеме этого поля. Листами поддерева являются примитивные
    типы, а их мы уже умеем генерировать. Сложность здесь заключается в том, что согласно формализации нашей задачи, мы должны
    так же сгенерировать подсказки для всех промежуточных объектных типов.
    \newpage
    \begin{example}
        Рассмотрим следующую схему некоторого поля:
        \begin{lstlisting}
    {
        "a": {
            "b": {
                "b1": "string"
            },
            "c": {
                "c1": "int32"
            }
    }
        \end{lstlisting}
        Перечислим все возможные TypeScript-типы, соответствующие этой схеме:
        \begin{lstlisting}
{a.b.b1: QPrimitiveType<string>}, {a.b: {b1: QPrimitiveType<string>} },
    {a: {b.b1: QPrimitiveType<string>} }, {a: {b: {b1: QPrimitiveType<string>} } },
{a.c.c1: QPrimitiveType<number>}, {a.c: {c1: QPrimitiveType<number>} },
    {a: {c.c1: QPrimitiveType<number>} }, {a: {c: {c1: QPrimitiveType<string>} } },
        \end{lstlisting}
        Далее средствами TypeScript можно будет очень просто сгенерировать все возможные попарные комбинации всех подтипов.
    \end{example}
    Ясно, что такая задача решается путём обхода дерева алгоритмом inorder walk\cite{inorderWalk}. Разберём реализацию на примере схемы из последнего
    примера:\\
    Рассмотрим дерево схемы некоторого поля (пускай будет $F$) из последнего примера:


    Создадим изначально пустой массив (types), в котором будем хранить строковые представления всех сгенерированных типов. Кроме того заведём строковую
    переменную (typeString), в которой будем содержать представлени типа, который мы генерируем на текущем этапе обхода. Представим сигнатуру функции обхода дерева:
    \begin{lstlisting}
        function inorderWalk(schema: Schema, field: string, arr?: boolean,
                    types: string[], typeString = "")
    \end{lstlisting}
    field --- поле, для которого мы сейчас генерируем тип, соответственно, схема этого поля достижима через конструкцию schema$[$field$]$, опциональный
    флаг arr показывает, является ли тип текущего field массивом.
    Реализация у функции довольно простая: если для очередного field тип schema$[$field$]$ не является объектным, то мы просто генерируем
    притивный тип, как мы это умеем, и доавляем в массив types строку
    \begin{lstlisting}
                    typeString + ": " + *(*@сгененрированный тип@*)*
    \end{lstlisting}
    Если же тип schema$[$field$]$ является объектным, то рассмотрим схему каждого подполя и запустим обход для соответствующего поддерева.


    Таким образом, к концу реализации данного этапа проекта мы имеем рабочий генератор системы типов, который по заданной схеме базы данных генерирует
    соответствующие TypeScript-типы, и передаёт их редактору Monaco Editor, что позволяет пользовать автодополнением кода при составлении запросов
    к определённому полю базы данных.

    \subsection{Билдеры запросов}
    Билдеры запросов, это ещё один способ сделать приложение удобнее в использовании. На данный момент единственный способ сделать запрос к базе данных,
    это воспользоваться методом api.query, и передать ему в качестве аргумента громоздкий объект, полями которого являются поля базы, а значениями полей ---
    некоторые операции над этими полями, возможно, целая последовательность операций.

    Появилась идея сделать ещё один способ отправки запросов на сервер: предположим, имеется класс Collection, методы которого одноимённы полям некоторой
    коллекции базы данных. Каждый из этих методов снова возвращает объект типа Collection. В качестве аргументов каждый метод принимает значение,
    тип которого совпадает с типом соответствующего поля коллекции, или специальный объект BuilderOptions<T>, который задаёт операцию над типом, и
    операнды, соответственно. Так же класс Collection содержит метод query, который делает запрос на сервер, собрав информацию по всем использованным методам.
    \begin{example}
        Пусть есть коллекция со следующей схемой:
        \begin{lstlisting}
    {
        "name": string,
        "surname": string,
        "birth_year": int
    }
        \end{lstlisting}
        И пусть есть соответствующий класс Collection, с четырьмя методами: name, surname, birth\_year, query. Тогда следующий запрос с использованием
        метода api.query, и с использованием класса Collection эквивалентны:
        \begin{lstlisting}
    api.query({author: {name: "Luise", surname: "Carrol", birth_year: 1832}});

    Collection.name("Luise").surname("Carrol").birth_year(1832).query();
        \end{lstlisting}

    \end{example}

    Существование такого класса позволяет сделать процесс составления запроса к базе ещё проще, т.к. в отличе от способа
    с api.query, в этом случае редактор уже не будет подсказывать миллион значений, и всевозвные значения для подполей, а для начала подскажет
    только названия основных полей, а после этого уже будет подсказывать тип и значения для конкретного поля.

    Реализация класса Collection максимально простая: по схеме коллекции генерируется $2n$ методов: $n$ статических, и столько же нестатических,
    где $n$ --- число полей схемы данной коллекции. У класса Collection имеет приватный конструктор, который принимает единственный аргумент:
    объект, соответствующий запросу. Этот приватный конструктор вызвается в каждом статическом методе при генерации нового объекта типа Collection.
    Каждый метод дополняет соответствующий запросу объект в соответствие с переданными аргументами, а нестатический метод query отдаёт этот объект
    в качестве аргумента методу api.query. Таким образом можно думать о классе Collection, как о более высокоуровневом API, чем api.query.
    \newpage


    \section{Заключение}
    В ходе программного проекта разработан рабочий концепт приложения для построения отчётов. Результат программного проекта содержит
    \begin{enumerate}
        \item WEB-редактор кода с поддержкой языка TypeScript и автодополнением кода;
        \item Возможность запускать написанный в редакторе код на исполнение;
        \item Возможность сделать запрос на сервер и получить ответ в виде отчёта;
        \item Возможность отрисовать отчёт в виде таблицы;
        \item Возможность экспортировать отчёт в формате csv для дальнейшего использования;
        \item Сгенерированную по схеме базы данных систему типов, по которой редактор умеет предлагать автодополнения при написании запроса;
        \item Билдеры запросов, которые позволяют делать запросы применением цепочки методов;
    \end{enumerate}
    В результате получен программный продукт, соответствующий всем указанным функциональным требованиям. В данный момент компания ALM Works уже
    занимается реализацией фактического приложения с использованием разработанного концепта.

    Как утверждалось в секции с обзором альтернатив --- основной альтернативой проекту являеся использование промышленной среды разработки,
    поэтому приведём формальное сравнени результатов проекта и возможностей промышленной среды разработки:
    \[
        \begin{tabular}{|
                >{\columncolor[HTML]{EFEFEF}}l |c|c|}
            \hline
            Инструмент разработки & \multicolumn{1}{l|}{\cellcolor[HTML]{EFEFEF}Report builder}
            & \multicolumn{1}{l|}{\cellcolor[HTML]{EFEFEF}\begin{tabular}[c]{@{}l@{}}
                                                              Промышленная IDE\\ (Intellij IDEA)
            \end{tabular}} \\ \hline
            Редактор кода    & {\color[HTML]{009901} +} & {\color[HTML]{009901} +} \\ \hline
            Автодополнение   & {\color[HTML]{009901} +} & {\color[HTML]{009901} +} \\ \hline
            Исполнение кода  & {\color[HTML]{009901} +} & {\color[HTML]{009901} +} \\ \hline
            Отрисовка отчёта & {\color[HTML]{009901} +} & {\color[HTML]{FE0000} -} \\ \hline
            Экспорт отчёта   & {\color[HTML]{009901} +} & {\color[HTML]{FE0000} -} \\ \hline
            Удобная отладка  & {\color[HTML]{FE0000} -} & {\color[HTML]{009901} +} \\ \hline
        \end{tabular}
    \]

    \newpage

    \bibliography{bib/references}
    \appendix


    \section{Приложение № 1. Календарный план работ}
    \[
        \includegraphics{plan.pdf}
    \]
    \newpage


    \section{Приложение № 2. Схема тестовой базы данных}
    \begin{lstlisting}
                {
                    "_id": "objectId",
                    "show_id": "string",
                    "type": "string",
                    "title": "string",
                    "director": "string",
                    "cast": {arr: true, element: "string"},
                    "country": "string",
                    "date_added": "datetime",
                    "release_year": "int32",
                    "rating": "string",
                    "duration": {"seasons": "int32", "mins": "int32"} },
                    "listed_in": {arr: true, element: "string"},
                    "description": "string"
                }
    \end{lstlisting}
\end{document}
